create table
  public.users (
    user_id bigint not null,
    username text not null,
    name text not null,
    constraint users_pkey primary key (user_id)
  ) tablespace pg_default;


create table
  public.nfts (
    --------------------------------
    nft_id serial not null, 
    collection_name text not null,
    address text not null,
    targetPrice integer null,
    currency text not null,
    chain text not null,
    user_id int8 not null,
    is_alert boolean null,
    --------------------------------
    constraint nfts_pkey primary key (nft_id),
    constraint nfts_user_id_fkey foreign key (user_id) references users (user_id)
  ) tablespace pg_default;

-------------------------ADDRESSES------------------------------------

0x51bb4c8bb4901d6aa061282cd7ed916eec715a29 - ETH
0x8a90cab2b38dba80c64b7734e58ee1db38b8992e - ETH
0x6ecfac3f581faf25086c95f30077e840681dde2a - MATIC
0x58318bceaa0d249b62fad57d134da7475e551b47 - ARB


// ... existing code ...

// New function to update NFT prices and check against target prices
async function updateAndCheckNftPrices() {
    for (const userId in chatStates) {
        const state = chatStates[userId];
        if (state?.nftData) { // Assuming nftData holds the relevant NFT information
            const nftData = state.nftData;

            // Fetch the latest price for the NFT (implement fetchLatestPrice as needed)
            const latestPrice = await fetchLatestPrice(nftData.contractAddress); // Replace with actual method to get the price

            // Update the price in nftData
            nftData.price = latestPrice;

            // Check if the latest price matches the target price
            if (nftData.is_target === latestPrice) {
                const message = `Alert: The price of ${nftData.name} has reached your target of ${nftData.is_target}!`;
                await bot.telegram.sendMessage(userId, message);
            }
        }
    }
}

// Set an interval to update prices and check target prices every 2 minutes
setInterval(updateAndCheckNftPrices, 2 * 60 * 1000); // 2 minutes in milliseconds

// Update the callback_query handler to store NFT data
bot.on("callback_query", async (ctx) => {
    // ... existing code ...
    
    switch (data) {
        // ... existing cases ...
        default:
            const alertNFT = await fetchNftWithName<NFTAlertWithPrice>(
                userId,
                data
            );
            if (!alertNFT) return;

            // Store the NFT data in chatStates for periodic checking
            chatStates[userId].nftData = alertNFT; // Store the NFT data
            showAlertNft(ctx, alertNFT);
            break;
    }
    return;
});

// ... existing code ...